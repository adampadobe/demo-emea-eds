/**
 * Copyright 2019 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */

const e="config";var t=async t=>{try{const t=await(n="alloyPushNotifications",o=1,r=t=>{t.objectStoreNames.contains(e)||t.createObjectStore(e,{keyPath:"id"})},new Promise((e,t)=>{const a=indexedDB.open(n,o);a.onerror=()=>t(a.error),a.onsuccess=()=>e(a.result),a.onupgradeneeded=e=>{const t=e.target.result;r&&r(t)}})),a=await((e,t,n)=>new Promise((o,r)=>{const a=e.transaction([t],"readonly").objectStore(t).get(n);a.onerror=()=>r(a.error),a.onsuccess=()=>o(a.result)}))(t,e,"alloyConfig");return t.close(),a}catch(e){t.error("Failed to read data from IndexedDB",{error:e})}var n,o,r};const n=[];for(let e=0;e<256;++e)n.push((e+256).toString(16).slice(1));let o;const r=new Uint8Array(16);var a={randomUUID:"undefined"!=typeof crypto&&crypto.randomUUID&&crypto.randomUUID.bind(crypto)};function i(e,t,i){if(a.randomUUID&&!e)return a.randomUUID();const c=(e=e||{}).random??e.rng?.()??function(){if(!o){if("undefined"==typeof crypto||!crypto.getRandomValues)throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");o=crypto.getRandomValues.bind(crypto)}return o(r)}();if(c.length<16)throw new Error("Random bytes length must be >= 16");return c[6]=15&c[6]|64,c[8]=63&c[8]|128,function(e,t=0){return(n[e[t+0]]+n[e[t+1]]+n[e[t+2]]+n[e[t+3]]+"-"+n[e[t+4]]+n[e[t+5]]+"-"+n[e[t+6]]+n[e[t+7]]+"-"+n[e[t+8]]+n[e[t+9]]+"-"+n[e[t+10]]+n[e[t+11]]+n[e[t+12]]+n[e[t+13]]+n[e[t+14]]+n[e[t+15]]).toLowerCase()}(c)}var c=async({xdm:e,actionLabel:n,applicationLaunches:o=0},{logger:r,fetch:a})=>{const c=await t(r),{browser:s,ecid:d,edgeDomain:l,edgeBasePath:u,datastreamId:m,datasetId:p}=c||{};let g={};n&&(g={customAction:{actionID:n}});const f=[{name:"browser",errorField:"Browser"},{name:"ecid",errorField:"ECID"},{name:"edgeDomain",errorField:"Edge domain"},{name:"edgeBasePath",errorField:"Edge base path"},{name:"datastreamId",errorField:"Datastream ID"},{name:"datasetId",errorField:"Dataset ID"}];try{for(const e of f)if(!c[e.name])throw new Error(`Cannot send tracking call. ${e.errorField} is missing.`);const t=`https://${l}/${u}/v1/interact?configId=${m}`,h={events:[{xdm:{identityMap:{ECID:[{id:d}]},timestamp:(new Date).toISOString(),pushNotificationTracking:{...g,pushProviderMessageID:i(),pushProvider:s.toLowerCase()},application:{launches:{value:o}},eventType:n?"pushTracking.customAction":"pushTracking.applicationOpened",_experience:{...e._experience,customerJourneyManagement:{...e._experience.customerJourneyManagement,pushChannelContext:{platform:"web"},messageProfile:{channel:{_id:"https://ns.adobe.com/xdm/channels/push"}}}}},meta:{collect:{datasetId:p}}}]},y=await a(t,{method:"POST",headers:{"content-type":"text/plain; charset=UTF-8"},body:JSON.stringify(h)});return!!y.ok||(r.error("Tracking call failed: ",y.status,y.statusText),!1)}catch(e){return r.error("Error sending tracking call:",e),!1}};const s=e=>["DEEPLINK","WEBURL"].includes(e);const d=self,l={namespace:"[alloy][pushNotificationWorker]",info:(...e)=>console.log(l.namespace,...e),error:(...e)=>console.error(l.namespace,...e)};d.addEventListener("install",()=>{d.skipWaiting()}),d.addEventListener("activate",e=>{e.waitUntil(d.clients.claim())}),d.addEventListener("push",e=>(async({sw:e,event:t,logger:n})=>{if(!t.data)return;let o;try{o=t.data.json()}catch(e){return void n.error("Error decoding notification JSON data:",e)}const r=o.web;if(!r?.title)return;const a={body:r.body,icon:r.media,image:r.media,data:r,actions:[]};return Object.keys(a).forEach(e=>{null==a[e]&&delete a[e]}),r.actions&&r.actions.buttons&&(a.actions=r.actions.buttons.map((e,t)=>({action:`action_${t}`,title:e.label}))),e.registration.showNotification(r.title,a)})({event:e,logger:l,sw:d})),d.addEventListener("notificationclick",e=>(({event:e,sw:t,logger:n,fetch:o})=>{e.notification.close();const r=e.notification.data;let a=null,i=null;if(e.action){const t=parseInt(e.action.replace("action_",""),10);if(r?.actions?.buttons[t]){const e=r.actions.buttons[t];i=e.label,s(e.type)&&e.uri&&(a=e.uri)}}else s(r?.interaction?.type)&&r?.interaction?.uri&&(a=r.interaction.uri);c({xdm:r._xdm.mixins,actionLabel:i,applicationLaunches:1},{logger:n,fetch:o}).catch(e=>{n.error("Failed to send tracking call:",e)}),a&&e.waitUntil(t.clients.matchAll({type:"window"}).then(e=>{for(const t of e)if(t.url===a&&"focus"in t)return t.focus();if(t.clients.openWindow)return t.clients.openWindow(a)}))})({event:e,sw:d,logger:l,fetch:fetch})),d.addEventListener("notificationclose",e=>{const t=e.notification.data;c({xdm:t._xdm.mixins,actionLabel:"Dismiss"},{logger:l,fetch:fetch}).catch(e=>{l.error("Failed to send tracking call:",e)})});
